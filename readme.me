üß† GOAL
Create a headless Python system that:

Continuously listens to CAN messages from a VESC.

Supports sending commands and receiving specific responses without blocking.

Exposes a simple, high-level Python API that students can use to interact with the ESC without understanding CAN.

üß± SYSTEM OVERVIEW
Runtime Components
Main Event Loop (main.py)

Central controller that:

Initializes the CAN interface.

Continuously listens for incoming CAN messages.

Maintains a registry of pending commands and handles responses.

Routes incoming messages to the correct handler (live stream vs response).

VESC Interface Layer (vesc_interface.py)

Encapsulates:

Low-level CAN send/receive.

Command serialization/deserialization.

Pending command tracking (UUID or command ID + timestamp).

Response timeouts and retries.

Command Encoders (commands.py)

Central location for creating properly encoded VESC command packets.

Response Parsers (protocol.py)

Contains functions to decode byte-level VESC responses into structured Python data.

üîÑ MAIN LOOP DESIGN
Use a non-blocking loop.

For each iteration:

Poll for new CAN messages.

Classify as:

Continuous stream ‚Üí pass to telemetry handler.

Response to command ‚Üí match to pending registry.

Cleanup expired commands.

Telemetry messages should update a shared state object (e.g., live_data), always available to the student API.

No command-response flow should block this loop.

üö© PENDING COMMAND REGISTRY
All commands that expect a response are stored with:

Timestamp

Expected response ID or parser function

Callback or future to resolve

On matching incoming message:

Call callback with decoded result

Remove from registry

On timeout:

Log failure

Optionally retry (one retry max)

Remove from registry

üß© MESSAGE FILTERING
Use message type or VESC command ID to route:

Live data updates (e.g., COMM_GET_VALUES) go to live_data state store.

File, Lisp, or control commands are matched against pending registry.

Unexpected packets are ignored (log in debug mode).

üßë‚Äçüéì STUDENT-FACING API DESIGN (student_api.py)
Purpose:
Allow students to interact with the vehicle via safe, intuitive Python functions.

Guidelines:
No exposure to CAN, message encoding, or protocol IDs.

Return clean data types (e.g., floats, strings, bools).

Fail gracefully with helpful error messages.

Architecture:
All API functions must internally:

Call into the vesc_interface.py send function.

Optionally await a response.

Return the result synchronously or via callback/future.

Read functions (e.g., get_speed, get_voltage):

Pull directly from the live telemetry store when possible.

Else, issue a one-time command and return response.

Write functions (e.g., set_duty, set_led_color):

Send a VESC command packet.

Optionally confirm success with a matching response.

Advanced commands (e.g., file access, Lisp):

Wrap with clear safeguards and pre-validation.

All filesystem operations sandboxed to a specific namespace or path.

üß™ TESTING REQUIREMENTS
Unit tests for all student API methods.

Integration tests simulating CAN message streams.

Ensure runtime stability under:

Heavy live stream traffic

Concurrent command/response flows

Lost or malformed packets

üìå Runtime Environment Notes
You are currently running on a Raspberry Pi Zero 2W with access to a VESC connected via the can0 interface (using a 500k baud CAN network). You can use this live hardware connection to automatically test your code via the CAN bus.

To (re)initialize the CAN interface reliably, run the following commands:

# Bring the interface down (in case it's already configured)
sudo ip link set can0 down

# Set the CAN interface parameters: bitrate = 500000
sudo ip link set can0 type can bitrate 500000

# Bring the interface back up
sudo ip link set can0 up
Once this is complete, the CAN interface will be live and listening on can0, allowing real-time communication with the VESC.


Testing and Validation

After bringing up the CAN interface, you can confirm the network is active using:

candump can0

Sending a ping or requesting firmware version from the VESC is a good first test command.

python-can is installed and used for all CAN communication.

The VESC that is on the CAN network has ID: 74

There is also an ESP32 running VESC-Express firmware on the can network with ID: 2

‚öôÔ∏è AI Coding Agent Operational Guidelines
üß† General Behavior
Do not make assumptions.
If you cannot confirm the expected behavior, structure, or data format from a reference file, explicitly ask for clarification.

Default to minimalism.
Avoid unnecessary abstraction, complexity, or speculative helper functions unless there is a clear benefit.

Prioritize compatibility.
Ensure all code is compatible with Python 3.7+ and runs on a Raspberry Pi Zero 2W with limited resources.

üîç Reference Handling
Always check available reference files first.
If implementing a command, data parser, or packet structure, verify against the official VESC reference files, headers, or existing implementation patterns.

If unsure, escalate.
Ask the human operator (me) before guessing. Include the exact section or detail you're unsure about.

üì¨ Communication Protocol
Never invent packet structures.
Encode/decode packets strictly based on known VESC protocol definitions. Unknown or partial fields must be left unimplemented until clarified.

Validate all send/receive logic.
All commands must include a check for an appropriate response or timeout, and return meaningful errors when applicable.

üß™ Testing & Safety
Never send motor/movement commands by default.
Any control commands (e.g., duty cycle, brake, throttle) must only be executed when explicitly invoked for testing.

Use candump can0 to verify live traffic.
This is a safe and non-intrusive way to confirm VESC messages are being broadcast before initiating command tests.